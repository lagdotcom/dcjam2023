import { execSync } from "child_process";
import { config as loadDotEnvConfig } from "dotenv";
import { writeFile } from "fs";

import { ClassName, ClassNames } from "../types/ClassName";
import { BoostableStats } from "../types/Combatant";
import Item from "../types/Item";
import KankaAPI from "./KankaAPI";
import {
  AbilityWithRelated,
  Attribute,
  CharacterWithRelated,
  CreatureWithRelated,
  EntityAbility,
  ItemWithRelated,
} from "./types";

interface KankaData {
  abilities: AbilityWithRelated[];
  characters: CharacterWithRelated[];
  creatures: CreatureWithRelated[];
  items: ItemWithRelated[];
}

function getToken() {
  const env = loadDotEnvConfig();

  if (env.error) throw new Error(env.error.message);

  if (!env.parsed) throw new Error("Could not parse .env");

  const token = env.parsed.KANKA_TOKEN;
  if (!token) throw new Error("No KANKA_TOKEN in .env");

  return token;
}

const header = "// This file is automatically generated by [yarn kanka]";

const fix = (s: string) => s.replace(" of ", " Of ").replace(/[^a-zA-Z]/g, "");
const byName = (a: { name: string }, b: { name: string }) =>
  a.name.localeCompare(b.name);

class AttributeBag {
  map: Map<string, string | null>;

  constructor(
    public context: string,
    attributes: Attribute[],
  ) {
    this.map = new Map(attributes.map((a) => [a.name.split("[")[0], a.value]));
  }

  hasAll(...names: string[]) {
    for (const name of names) {
      const value = this.opt(name);
      if (!value) return false;
    }
    return true;
  }

  req(name: string) {
    const value = this.map.get(name);
    if (value === null || value === undefined)
      throw new Error(`${this.context}: missing attribute ${name}`);
    return value;
  }

  opt(name: string) {
    const value = this.map.get(name);
    return value === null || value === undefined ? undefined : value.trim();
  }

  use(name: string, fn: (value: string) => void) {
    const value = this.opt(name);
    if (value) fn(value);
  }

  useNZ(name: string, fn: (value: string) => void) {
    const value = this.opt(name);
    if (value && value !== "0") fn(value);
  }

  format(name: string, fmt: (value: string) => string) {
    const value = this.opt(name);
    return value ? fmt(value) : "";
  }

  formatNZ(name: string, fmt: (value: string) => string) {
    const value = this.opt(name);
    return value && value !== "0" ? fmt(value) : "";
  }
}

const abilityNameGetter =
  (context: string, abilities: AbilityWithRelated[]) =>
  (ea?: EntityAbility) => {
    const ability = abilities.find((a) => a.id === ea?.ability_id);
    if (!ability) throw new Error(`Could not find ability for ${context}`);
    return fix(ability.name);
  };

function tsAction(ability: AbilityWithRelated) {
  const name = fix(ability.name);
  const attr = new AttributeBag(`action ${ability.name}`, ability.attributes);

  const targets: Record<string, unknown> = { type: attr.req("Target Type") };
  if (targets.type !== "self") {
    attr.useNZ("Target Count", (value) => (targets.count = Number(value)));
    attr.useNZ(
      "Target Distance",
      (value) => (targets.distance = Number(value)),
    );
    attr.use(
      "Target Offsets",
      (value) => (targets.offsets = value.split(",").map(Number)),
    );
  }

  return `export const ${name}: CombatAction = {
    name: "${ability.name}",
    tags: [],
    sp: ${attr.req("SP Cost")}, ${attr.formatNZ(
      "Costs all SP?",
      () => "x: true,",
    )}
    targets: ${JSON.stringify(targets)},
    act: impl.${name},
  };`;
}
function tsActions({ abilities }: KankaData) {
  return `${header}
  import * as impl from "./actionImplementations";
  import CombatAction from "./types/CombatAction";

  ${abilities.sort(byName).map(tsAction).join("\n\n")}`;
}

function tsClasses(data: KankaData) {
  return `${header}`;
}

function tsEnemy(
  creature: CreatureWithRelated,
  abilities: AbilityWithRelated[],
) {
  const name = fix(creature.name);
  const attr = new AttributeBag(`enemy ${creature.name}`, creature.attributes);
  const getAbilityName = abilityNameGetter(`enemy ${creature.name}`, abilities);

  return `export const ${name}: EnemyData = {
    name: "${creature.name}",
    maxHP: ${attr.req("HP")},
    maxSP: ${attr.req("SP")},
    camaraderie: ${attr.req("CAM")},
    determination: ${attr.req("DTM")},
    spirit: ${attr.req("SPT")},
    dr: ${attr.opt("DR") ?? 0},
    actions: [${creature.entity_abilities
      .map(getAbilityName)
      .map((name) => `actions.${name}`)
      .join(",")}]
  };`;
}

function validCreature(creature: CreatureWithRelated) {
  const attr = new AttributeBag("", creature.attributes);
  if (attr.hasAll("HP", "SP", "CAM", "DTM", "SPT")) return true;

  console.log(`-- skipping creature: ${creature.name}`);
  return false;
}

function tsEnemies({ abilities, creatures }: KankaData) {
  return `${header}
  import * as actions from "./actions";
  import Enemy from "./Enemy";

  type EnemyData = Pick<Enemy,'name'|'maxHP'|'maxSP'|'camaraderie'|'determination'|'spirit'|'dr'|'actions'>;
  
  ${creatures
    .filter(validCreature)
    .sort(byName)
    .map((c) => tsEnemy(c, abilities))
    .join("\n\n")}`;
}

function tsItem(item: ItemWithRelated, abilities: AbilityWithRelated[]) {
  const name = fix(item.name);
  const attr = new AttributeBag(`item ${item.name}`, item.attributes);
  const getAbilityName = abilityNameGetter(`item ${item.name}`, abilities);

  const restrict: ClassName[] = [];
  for (const cn of ClassNames) attr.useNZ(cn, () => restrict.push(cn));

  const bonus: Item["bonus"] = {};
  for (const stat of BoostableStats)
    attr.useNZ(stat, (value) => (bonus[stat] = Number(value)));

  let type = item.type;
  if (type === "Armor") type = "Armour";

  return `export const ${name}: Item = {
    name: "${item.name}",
    restrict: ${JSON.stringify(restrict)},
    slot: "${attr.req("Slot")}",
    type: "${type}",
    bonus: ${JSON.stringify(bonus)},
    action: actions.${getAbilityName(item.entity_abilities[0])}, ${attr.format(
      "Lore",
      (value) => `lore: \`${value}\`,`,
    )}
  };`;
}

function validItem(item: ItemWithRelated) {
  const attr = new AttributeBag("", item.attributes);
  if (attr.hasAll("Slot") && item.type && item.entity_abilities.length > 0)
    return true;

  console.log(`-- skipping item: ${item.name}`);
  return false;
}

function tsItems({ abilities, items }: KankaData) {
  const validItems = items.filter(validItem).sort(byName);

  return `${header}
  import * as actions from "./actions";
  import Item from "./types/Item";

  ${validItems.map((item) => tsItem(item, abilities)).join("\n\n")}

  export const allItems = Object.fromEntries(
    [${validItems
      .map((i) => fix(i.name))
      .join(",")}].map((item) => [item.name, item]),
  );

  export function getItem(s?: string) {
    return s ? allItems[s] : undefined;
  }
`;
}

function write(fn: string, data: string) {
  console.log("Writing:", fn);
  return new Promise<string>((resolve) =>
    writeFile(fn, data, { encoding: "utf-8" }, () => resolve(fn)),
  );
}

async function main() {
  const token = getToken();
  const api = new KankaAPI(token);
  const pd = api.campaign(222560);

  const abilities = await pd.allAbilities();
  const characters = await pd.allCharacters();
  const creatures = await pd.allCreatures();
  const items = await pd.allItems();
  const data: KankaData = { abilities, characters, creatures, items };

  const filenames = await Promise.all([
    write("./src/actions.ts", tsActions(data)),
    write("./src/kanka/classes.ts", tsClasses(data)),
    write("./src/enemyData.ts", tsEnemies(data)),
    write("./src/items.ts", tsItems(data)),
  ]);

  console.log("Fixing formatting...");
  try {
    execSync(`yarn eslint --fix ${filenames.join(" ")}`);
  } catch {
    /* empty */
  }
}

void main();
