/*eslint-env node*/

import { config as loadDotEnvConfig } from "dotenv";
import { readFileSync, writeFileSync } from "fs";

const getKanka = (token, version = `1.0`, campaignId = 222560) => {
  const baseUrl = `https://api.kanka.io/${version}/`;
  const campaignUrl = `${baseUrl}campaigns/${campaignId}/`;
  const headers = new Headers();
  headers.set("Authorization", `Bearer ${token}`);
  headers.set("Content-type", "application/json");

  return [
    /** @param {string} url */
    (url) => {
      // console.log("fetch:", baseUrl + url);
      return fetch(baseUrl + url, { headers });
    },
    /** @param {string} url */
    (url) => {
      // console.log("fetch:", baseUrl + url);
      return fetch(campaignUrl + url, { headers });
    },
  ];
};

/**
 * @param {import("./src/types/Kanka").KankaEntityWithAttributes} e
 * @param {string} name
 * @returns {string|null}
 */
const attr = (e, name) =>
  e.attributes.find((a) => a.name.split("[")[0] === name).value;

function getActionMaker() {
  /**
   * @param {import("./src/types/Kanka").KankaEntityWithAttributes} e
   * @returns {import("./src/items/kankaData").ActionTemplate}
   */
  return function (e) {
    const sp = attr(e, "SP Cost");

    const action = {
      name: e.name,
      tags: [],
      sp: Number(sp),
    };
    if (attr(e, "Costs all SP?") === "1") action.x = true;

    const targetType = attr(e, "Target Type");
    const targets = { type: targetType };
    action.targets = targets;

    if (targetType !== "self") {
      const count = attr(e, "Target Count");
      if (count) targets.count = Number(count);

      const distance = attr(e, "Target Distance");
      if (distance) targets.distance = Number(distance);

      const offsets = attr(e, "Target Offsets");
      if (offsets) targets.offsets = offsets.split(",").map(Number);
    }

    return action;
  };
}

const classnames = [
  "Martialist",
  "Cleavesman",
  "Far Scout",
  "War Caller",
  "Flag Singer",
  "Loam Seer",
];

const stats = [
  "dr",
  "maxHP",
  "maxSP",
  "camaraderie",
  "determination",
  "spirit",
];

/** @param {import("./src/types/Kanka").KankaEntityWithAttributes[]} allEntities */
function getItemMaker(allEntities) {
  /**
   * @param {import("./src/types/Kanka").KankaEntityWithAttributes} e
   * @returns {import("./src/items/kankaData").ItemTemplate}
   */
  return function (e) {
    const item = {
      name: e.name,
      restrict: [],
      slot: attr(e, "Slot"),
      type: attr(e, "Type"),
      bonus: {},
    };
    for (const cn of classnames)
      if (attr(e, cn) === "1") item.restrict.push(cn);

    for (const st of stats) {
      const bonus = attr(e, st);
      if (bonus) item.bonus[st] = Number(bonus);
    }

    const action = attr(e, "Action");
    if (action) {
      const filter = action.startsWith("[ability:")
        ? (a) => a.id === Number(action.slice(9, -1))
        : (a) => a.name === action;

      const ab = allEntities.find((a) => a.type === "ability" && filter(a));
      if (ab) item.action = ab.name;
      else console.warn(`Could not find action: ${action}`);
    }

    const lore = attr(e, "Lore");
    if (lore) item.lore = lore;

    return item;
  };
}

/**
 * @param {string} name
 * @returns {string}
 */
const fixName = (name) => name.replace(/ /g, "");

/**
 * @param {import("./src/items/kankaData").ActionTemplate[]} actions
 * @param {import("./src/items/kankaData").ItemTemplate[]} items
 * @returns {string}
 */
function makeKankaDataFile(actions, items) {
  return `// This file is automatically generated by kanka.mjs
import CombatAction from "../types/CombatAction";
import Item from "../types/Item";

export type ActionTemplate = Omit<CombatAction, 'act'>;
export const Actions = ${JSON.stringify(
    Object.fromEntries(actions.map((a) => [fixName(a.name), a]))
  )} satisfies Record<string, ActionTemplate>;

export type ItemTemplate = Omit<Item, 'action'> & { action: keyof typeof Actions };
export const Items = ${JSON.stringify(
    Object.fromEntries(items.map((i) => [fixName(i.name), i]))
  )} satisfies Record<string, ItemTemplate>;
`;
}

const out = (obj) => console.dir(obj, { depth: Infinity });

const kankaCacheFile = "./local-only/latest-kanka-data.json";

async function getEntitiesFromKanka() {
  const env = loadDotEnvConfig();

  if (env.error) {
    console.error(env.error.message);
    return;
  }

  if (!env.parsed) {
    console.error("Could not parse .env");
    return;
  }

  const token = env.parsed.KANKA_TOKEN;
  if (!token) {
    console.error("No KANKA_TOKEN in .env");
    return;
  }

  const [kanka, pd] = getKanka(token);

  /** @type {import('./src/types/Kanka').KankaListRequest<import("./src/types/Kanka").KankaEntityWithAttributes>} */
  const all = await (
    await pd("entities?types=item,ability&related=attribute")
  ).json();
  writeFileSync(kankaCacheFile, JSON.stringify(all), {
    encoding: "utf-8",
  });

  return all;
}

/** @returns {import('./src/types/Kanka').KankaListRequest<import("./src/types/Kanka").KankaEntityWithAttributes>} */
function getEntitiesFromCache() {
  return JSON.parse(
    readFileSync(kankaCacheFile, {
      encoding: "utf-8",
    })
  );
}

const kankaOutFile = "./src/items/kankaData.ts";

async function main() {
  const all = await getEntitiesFromCache();

  const makeAction = getActionMaker();
  const makeItem = getItemMaker(all.data);

  const actions = all.data.filter((e) => e.type === "ability").map(makeAction);
  const items = all.data.filter((e) => e.type === "item").map(makeItem);

  console.log("Writing:", kankaOutFile);
  writeFileSync(kankaOutFile, makeKankaDataFile(actions, items), {
    encoding: "utf-8",
  });
}

void main();
